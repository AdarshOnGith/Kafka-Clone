package com.distributedmq.storage.controller;

import com.distributedmq.common.dto.ProduceRequest;
import com.distributedmq.common.dto.ProduceResponse;
import com.distributedmq.common.dto.ConsumeRequest;
import com.distributedmq.common.dto.ConsumeResponse;
import com.distributedmq.storage.service.StorageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

/**
 * REST Controller for Storage operations
 * Entry point with request validation
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/storage")
@RequiredArgsConstructor
public class StorageController {

    private final StorageService storageService;

    /**
     * Produce messages to partition (leader only)
     * Endpoint: POST /api/v1/storage/messages
     */
    @PostMapping("/messages")
    public ResponseEntity<ProduceResponse> produceMessages(
            @Validated @RequestBody ProduceRequest request) {
        
        log.info("Received produce request for topic: {}, partition: {}, messageCount: {}", 
                request.getTopic(), request.getPartition(), 
                request.getMessages() != null ? request.getMessages().size() : 0);
        
        // Step 1: Broker Reception & Validation
        ProduceResponse.ErrorCode validationError = validateProduceRequest(request);
        if (validationError != ProduceResponse.ErrorCode.NONE) {
            return ResponseEntity.ok(ProduceResponse.builder()
                    .topic(request.getTopic())
                    .partition(request.getPartition())
                    .success(false)
                    .errorCode(validationError)
                    .errorMessage(validationError.getMessage())
                    .build());
        }
        
        // Check if this broker is the partition leader
        if (!storageService.isLeaderForPartition(request.getTopic(), request.getPartition())) {
            return ResponseEntity.ok(ProduceResponse.builder()
                    .topic(request.getTopic())
                    .partition(request.getPartition())
                    .success(false)
                    .errorCode(ProduceResponse.ErrorCode.NOT_LEADER_FOR_PARTITION)
                    .errorMessage("Not leader for partition")
                    .build());
        }
        
        // TODO: Validate producer ID and epoch for idempotent producers
        ProduceResponse.ErrorCode producerValidationError = validateProducerIdAndEpoch(request);
        if (producerValidationError != ProduceResponse.ErrorCode.NONE) {
            return ResponseEntity.ok(ProduceResponse.builder()
                    .topic(request.getTopic())
                    .partition(request.getPartition())
                    .success(false)
                    .errorCode(producerValidationError)
                    .errorMessage(producerValidationError.getMessage())
                    .build());
        }
        
        try {
            ProduceResponse response = storageService.appendMessages(request);
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("Error processing produce request", e);
            
            return ResponseEntity.ok(ProduceResponse.builder()
                    .topic(request.getTopic())
                    .partition(request.getPartition())
                    .success(false)
                    .errorCode(ProduceResponse.ErrorCode.INVALID_REQUEST)
                    .errorMessage("Internal server error: " + e.getMessage())
                    .build());
        }
    }

    /**
     * Fetch messages from partition
     */
    @PostMapping("/consume")
    public ResponseEntity<ConsumeResponse> consume(
            @Validated @RequestBody ConsumeRequest request) {
        
        log.debug("Received consume request for topic: {}, partition: {}, offset: {}", 
                request.getTopic(), request.getPartition(), request.getOffset());
        
        // Sanity checks
        if (request.getTopic() == null || request.getTopic().isEmpty()) {
            throw new IllegalArgumentException("Topic cannot be empty");
        }
        
        if (request.getOffset() < 0) {
            throw new IllegalArgumentException("Offset must be non-negative");
        }
        
        ConsumeResponse response = storageService.fetch(request);
        
        return ResponseEntity.ok(response);
    }

    /**
     * Get partition high water mark
     */
    @GetMapping("/partitions/{topic}/{partition}/high-water-mark")
    public ResponseEntity<Long> getHighWaterMark(
            @PathVariable String topic,
            @PathVariable Integer partition) {
        
        log.debug("Getting high water mark for topic: {}, partition: {}", topic, partition);
        
        Long highWaterMark = storageService.getHighWaterMark(topic, partition);
        
        return ResponseEntity.ok(highWaterMark);
    }

    /**
     * Validate produce request
     */
    private ProduceResponse.ErrorCode validateProduceRequest(ProduceRequest request) {
        if (request.getTopic() == null || request.getTopic().isEmpty()) {
            return ProduceResponse.ErrorCode.INVALID_REQUEST;
        }
        
        if (request.getPartition() == null || request.getPartition() < 0) {
            return ProduceResponse.ErrorCode.INVALID_REQUEST;
        }
        
        if (request.getMessages() == null || request.getMessages().isEmpty()) {
            return ProduceResponse.ErrorCode.INVALID_REQUEST;
        }
        
        // Validate each message
        for (ProduceRequest.ProduceMessage message : request.getMessages()) {
            if (message.getValue() == null || message.getValue().length == 0) {
                return ProduceResponse.ErrorCode.INVALID_REQUEST;
            }
            
            // TODO: Check message size limits
            // 1. Check individual message size against max.message.bytes
            // 2. Check total batch size against max.request.size
            // 3. Return MESSAGE_TOO_LARGE error if exceeded
            // 4. Log size violation for monitoring

        }
        
        // Validate acks
        if (request.getRequiredAcks() != null && 
            request.getRequiredAcks() != 0 && 
            request.getRequiredAcks() != 1 && 
            request.getRequiredAcks() != -1) {
            return ProduceResponse.ErrorCode.INVALID_REQUEST;
        }

        return ProduceResponse.ErrorCode.NONE;
    }

    /**
     * Validate producer ID and epoch for idempotent producers
     */
    private ProduceResponse.ErrorCode validateProducerIdAndEpoch(ProduceRequest request) {
        // TODO: Validate producer ID and epoch for idempotent producers
        // 1. Check if producerId is provided (non-null)
        // 2. Query stored producer state for last epoch/sequence
        // 3. Validate sequence number is monotonically increasing
        // 4. Return OUT_OF_ORDER_SEQUENCE error if invalid or handle it as needed.

        // For now, return NONE (no validation implemented yet)
        return ProduceResponse.ErrorCode.NONE;
    }

    // TODO: Add replication endpoints
    // 1. POST /api/v1/storage/replicate - Receive replication requests from leader
    // 2. GET /api/v1/storage/replicate/status - Check replication progress
    // 3. POST /api/v1/storage/replicate/ack - Send replication acknowledgments
    // 4. Implement follower-side validation and append logic
    
    // TODO: Add partition management endpoints
    // 1. POST /api/v1/storage/partitions - Create new partition
    // 2. DELETE /api/v1/storage/partitions/{topic}/{partition} - Delete partition
    // 3. GET /api/v1/storage/partitions/{topic} - List topic partitions
    // 4. POST /api/v1/storage/partitions/leader - Update partition leadership
}
